package org.example;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.*;

public class Client {
    private static final Logger logger = LogManager.getLogger(Client.class);
    private final String clientId; // c: self client_id
    private Map<String, ServerDetails> servers; // [servers]: Map of all server ids and their connection info
    private String leaderId; // leader: Current leader id
    private final StubManager stubManager;
    private final ExecutorService networkExecutor;

    public Client(String clientId) {
        this.clientId = clientId;
        this.servers = new HashMap<>();
        this.leaderId = "n1";


        try {
            this.servers = Config.getServers();
            this.stubManager = new StubManager();
            this.networkExecutor = Executors.newCachedThreadPool(); // Thread pool for handling network operations
        } catch (Exception e) {
//            logger.error("Client {}: Failed to load server details from path defined in config.properties : {}", clientId, e.getMessage());
            throw new RuntimeException(e);
        }
    }

    /**
     * Generates a ClientRequest proto message.
     *
     * @param transaction The transaction object (from the class generated by grpc)
     * @return ClientRequest proto message
     */
    static MessageServiceOuterClass.ClientRequest generateClientRequest(MessageServiceOuterClass.Transaction transaction) {
        long timestamp = System.currentTimeMillis();
        return MessageServiceOuterClass.ClientRequest.newBuilder().setTransaction(transaction).setTimestamp(timestamp).setClientId(transaction.getSender()).build();
    }

    private boolean isSuccess(MessageServiceOuterClass.ClientReply reply) {
        return reply != null;
    }

//    Client request methods

    // Send client request once with timeout
    private MessageServiceOuterClass.ClientReply sendClientRequestWithTimeout(
            MessageServiceOuterClass.ClientRequest request, String serverId) {
        try {
            MessageServiceGrpc.MessageServiceBlockingStub stub = stubManager.getBlockingStub(serverId)
                    .withDeadlineAfter(500, TimeUnit.MILLISECONDS); // adjust as needed
            return stub.request(request);
        } catch (Exception e) {
//            logger.warn("Client {}: RPC to {} failed", clientId, serverId);
            return null;
        }
    }

    public void processTransaction(MessageServiceOuterClass.Transaction transaction) {
        MessageServiceOuterClass.ClientRequest request = generateClientRequest(transaction); // keep your existing builder
        int attempt = 0;

        while (true) {
            attempt++;

            // 1) Try known leader with a short deadline
            if (leaderId != null) {
                MessageServiceOuterClass.ClientReply leaderReply = sendClientRequestWithTimeout(request, leaderId);
                if (isSuccess(leaderReply)) {
                    this.leaderId = leaderReply.getSenderId(); // update only on success
                    logger.info("Client {}: success via leader {}", clientId, leaderId);
                    break;
                }
            }

            // 2) Race a broadcast to all servers; first true wins and cancels the rest
            MessageServiceOuterClass.ClientReply winner = broadcastUntilFirstSuccess(request);
            if (isSuccess(winner)) {
                this.leaderId = winner.getSenderId(); // promote the winning replier to leader
                logger.info("Client {}: success via broadcast, new leader={}", clientId, leaderId);
                break;
            }

            // 3) Backoff before retrying the round
            long backoffMs = Math.min(1000L, 50L * (1L << Math.min(5, attempt)));
            try {
                TimeUnit.MILLISECONDS.sleep(backoffMs);
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
//            throw new RuntimeException("Interrupted while retrying", ie);
            }
        }

        logger.info("Client {}: processed transaction ({}, {}, {})", clientId,
                transaction.getSender(), transaction.getReceiver(), transaction.getAmount());
    }

    private boolean parseServerReply(MessageServiceOuterClass.ClientReply reply) {
        if (reply != null) {
            if (reply.getResult()) {
//                logger.info("Client {}: Transaction successful.", clientId);
                this.leaderId = reply.getSenderId();
//                logger.info("Client {}: Updated leader ID to node {}.", clientId, leaderId);
            }
//            else logger.info("Client {}: Transaction failed.", clientId);
            return true;
        } else {
            this.leaderId = null;
//            logger.error("Client {}: Client received no reply.", clientId);
            return false;
        }
    }

    private MessageServiceOuterClass.ClientReply broadcastUntilFirstSuccess(
            MessageServiceOuterClass.ClientRequest request) {

        CompletionService<MessageServiceOuterClass.ClientReply> cs =
                new ExecutorCompletionService<>(networkExecutor);
        java.util.concurrent.atomic.AtomicBoolean done = new java.util.concurrent.atomic.AtomicBoolean(false);
        java.util.List<Future<MessageServiceOuterClass.ClientReply>> futures = new java.util.ArrayList<>();

        for (final String serverId : servers.keySet()) {
            futures.add(cs.submit(() -> {
                if (done.get()) return null;
                MessageServiceOuterClass.ClientReply r = sendClientRequestWithTimeout(request, serverId);
                if (isSuccess(r) && done.compareAndSet(false, true)) {
                    return r;
                }
                return null;
            }));
        }

        MessageServiceOuterClass.ClientReply winner = null;
        int remaining = futures.size();
        while (remaining-- > 0 && !done.get()) {
            try {
                Future<MessageServiceOuterClass.ClientReply> f = cs.take();
                MessageServiceOuterClass.ClientReply r = f.get();
                if (isSuccess(r)) {
                    winner = r;
                    break;
                }
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
                break;
            } catch (ExecutionException e) {
                // ignore and continue waiting
            }
        }

        // Cancel stragglers once a winner is found
        if (winner != null) {
            done.set(true);
            for (Future<?> f : futures) f.cancel(true);
        }
        return winner; // may be null if no server succeeded this round
    }

    private MessageServiceOuterClass.ClientReply broadcastRequest(MessageServiceOuterClass.ClientRequest request) {

        int serverCount = servers.size();

        try {
            CompletionService<MessageServiceOuterClass.ClientReply> completionService = new ExecutorCompletionService<>(networkExecutor);
            for (final String serverId : servers.keySet()) {
                completionService.submit(new SendRequestCallable(request, serverId));
            }

            for (int i = 0; i < serverCount; i++) {
                Future<MessageServiceOuterClass.ClientReply> future = completionService.take();
                try {
//                    Return the very first reply from the broadcast
//                    networkExecutor.shutdownNow(); // Do I need this here?
                    return future.get();
                } catch (InterruptedException | ExecutionException e) {
//                    logger.error("Client {}: Error while waiting for broadcast reply.", clientId, e);
                    throw new RuntimeException(e);
                }
            }
        } catch (Exception e) {
//            logger.error("Client {}: Error in spawning multiple threads for broadcast", clientId, e);
        }

        return null;
    }

    private class SendRequestCallable implements Callable<MessageServiceOuterClass.ClientReply> {

        MessageServiceOuterClass.ClientRequest request;
        String serverId;

        public SendRequestCallable(MessageServiceOuterClass.ClientRequest request, String serverId) {
            this.request = request;
            this.serverId = serverId;
        }

        @Override
        public MessageServiceOuterClass.ClientReply call() {
            try {
//                logger.info("Client {}: Broadcasting request ({}, {}, {}) to server {}.", clientId, request.getTransaction().getSender(), request.getTransaction().getReceiver(), request.getTransaction().getAmount(), serverId);
                return sendClientRequestWithTimeout(request, serverId);
            } catch (Exception e) {
//                logger.error("Client {}: Error broadcasting request to server {} : {}", clientId, serverId, e.getMessage());
            }
            return null;
        }
    }

}